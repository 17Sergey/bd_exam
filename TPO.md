### 1. Что такое тестирование программного обеспечения? В чём заключается цель тестирования ПО?

**Тестирование программного обеспечения** (ПО) — это процесс выполнения программы или системы с целью выявления ошибок или дефектов, а также проверки соответствия системы требуемым характеристикам. Это включает в себя различные методы, такие как выполнение тестов, анализ кода, проверку функциональности, производительности и безопасности.

**Цель тестирования ПО**:

- **Выявление дефектов**: Тестирование помогает обнаружить ошибки и дефекты в программе до того, как продукт попадет в руки пользователя.
    
- **Проверка соответствия требованиям**: Тестирование подтверждает, что программа соответствует заявленным требованиям, функциональным и нефункциональным характеристикам.
    
- **Обеспечение качества**: Тестирование способствует улучшению качества программного продукта, проверяя его надежность, производительность, безопасность и удобство использования.
    
- **Снижение рисков**: Тестирование помогает минимизировать риски, связанные с выходом багов или сбоев в продуктивную среду.
    

---

### 2. История тестирования программного обеспечения. Основные вехи.

**История тестирования ПО** охватывает несколько ключевых этапов, каждый из которых привнес свою роль в развитие практики тестирования:

1. **1940-1960-е годы**: Тестирование как отдельная дисциплина почти не существовало. Программисты часто тестировали код, проверяя его в процессе разработки.
    
2. **1970-е годы**: Начало формулирования концепций и методов для структурированного тестирования ПО. Разработка первых подходов к тестированию, таких как **методика белого ящика** и **методика черного ящика**.
    
3. **1980-е годы**: Появление первых специализированных инструментов и стандартов для автоматизации тестирования и анализа качества. Введение концепции **тестирования как отдельного этапа разработки**.
    
4. **1990-е годы**: Развитие методологий, таких как **TDD** (Test-Driven Development), **методологии управления качеством** и формирование специализированных ролей, таких как **QA** (Quality Assurance).
    
5. **2000-е годы**: Эпоха интеграции тестирования в процесс CI/CD (непрерывной интеграции и доставки), автоматизация тестирования, использование инструментов для **нагрузочного тестирования** и **тестирования безопасности**.
    
6. **Современность**: Акцент на **agile-тестирование**, **микросервисах** и **инструментах для автоматизации тестирования**. Применение **искусственного интеллекта** и **машинного обучения** для предсказания ошибок и улучшения тестовых процессов.
    

---

### 3. Обеспечение качества: терминология, ISO/IEC 25010:2011 (Модель качества при использовании)

**Обеспечение качества (QA)** — это систематический процесс, который направлен на создание уверенности, что продукт или услуга соответствует требуемым стандартам и критериям качества. QA охватывает весь процесс разработки и эксплуатации программного обеспечения, а не только этап тестирования.

**ISO/IEC 25010:2011** — это международный стандарт, который описывает модель качества программного обеспечения, определяя восемь характеристик, которые должны быть проверены для оценки качества ПО.

#### Основные характеристики модели качества по ISO/IEC 25010:

1. **Функциональная пригодность** (Functional Suitability): Способность системы выполнять свои функции в соответствии с требованиями.
    
2. **Производительность** (Performance Efficiency): Эффективность работы системы в условиях ресурсов, таких как время отклика, использование памяти и т.д.
    
3. **Совместимость** (Compatibility): Насколько система может работать с другими системами и функционировать на разных платформах.
    
4. **Удобство использования** (Usability): Легкость, с которой пользователь может взаимодействовать с системой.
    
5. **Надежность** (Reliability): Способность системы работать без сбоев в течение определенного времени.
    
6. **Безопасность** (Security): Способность системы защищать данные от несанкционированного доступа и использования.
    
7. **Сопровождаемость** (Maintainability): Легкость в обновлении и исправлении системы.
    
8. **Переносимость** (Portability): Способность системы работать в различных окружениях или быть перенесенной на новые платформы.
    

---

### 4. Модель качества продукта по стандарту ISO/IEC 25010:2011

Модель качества программного обеспечения по **ISO/IEC 25010:2011** состоит из восьми характеристик, каждая из которых представляет собой важный аспект оценки качества ПО:

1. **Функциональная пригодность (Functional Suitability)**:
    
    - Полнота и правильность функциональности программного продукта.
        
    - Соответствие требованиям заказчика и пользователей.
        
2. **Производительность (Performance Efficiency)**:
    
    - Эффективность использования ресурсов, таких как процессорное время, память и другие вычислительные ресурсы.
        
    - Время отклика и стабильность работы при нагрузках.
        
3. **Совместимость (Compatibility)**:
    
    - Способность взаимодействовать с другими системами, а также поддержка разных версий и платформ.
        
    - Взаимодействие с другими приложениями, оборудованием и операционными системами.
        
4. **Удобство использования (Usability)**:
    
    - Оценка удобства взаимодействия пользователя с системой.
        
    - Легкость освоения системы и выполнения задач.
        
5. **Надежность (Reliability)**:
    
    - Способность системы выполнять свои функции без сбоев.
        
    - Устойчивость к ошибкам и отказам, доступность системы.
        
6. **Безопасность (Security)**:
    
    - Защищенность от несанкционированного доступа, утечек данных, угроз безопасности.
        
    - Способность системы предотвращать внешние и внутренние атаки.
        
7. **Сопровождаемость (Maintainability)**:
    
    - Легкость исправления ошибок, улучшения функциональности, адаптации к изменениям.
        
    - Оценка, как легко можно поддерживать систему в рабочем состоянии.
        
8. **Переносимость (Portability)**:
    
    - Способность системы работать в различных окружениях, на разных устройствах, с разными версиями операционных систем.
        

---

### 5. Дайте определение следующим терминам: обеспечение качества (QA), контроль качества, тестирование программного обеспечения. В чем отличие QA от тестирования?

#### Обеспечение качества (QA):

**Обеспечение качества (QA)** — это широкая концепция, включающая все процессы, методы и инструменты, направленные на улучшение качества продукта на протяжении всего жизненного цикла разработки. QA охватывает не только тестирование, но и предотвращение ошибок, улучшение процессов разработки и контроля качества.

#### Контроль качества (QC):

**Контроль качества (QC)** — это процесс обнаружения дефектов в готовом продукте, в основном через тестирование. QC является частью более широкой концепции обеспечения качества (QA), которая включает в себя планирование, аудит и анализ процессов, а QC фокусируется исключительно на проверке качества уже готового продукта.

#### Тестирование программного обеспечения:

**Тестирование программного обеспечения** — это процесс проверки и оценки функциональности и качества программы с целью выявления ошибок. Тестирование включает в себя создание и выполнение тестов для проверки правильности работы системы, а также определение производительности, безопасности и других характеристик продукта.

#### Отличие QA от тестирования:

- **QA (обеспечение качества)** включает в себя все процессы, которые направлены на улучшение и гарантирование качества на протяжении всего жизненного цикла продукта. Это более широкий процесс, который включает в себя планирование, мониторинг и улучшение.
    
- **Тестирование** — это одна из функций в рамках QA, которая заключается в непосредственном проведении проверок и тестов с целью выявления ошибок и дефектов в программном обеспечении.
    

QA — это стратегический процесс, который включает в себя тестирование, но не ограничивается им.

### 6. Что входит в обязанности тестировщика программного обеспечения (QA-тестировщика) и специалиста по тестированию программного обеспечения (QA-инженера)? Чем QA-тестировщик отличается от QA-инженера?

#### Обязанности **QA-тестировщика**:

1. **Подготовка тестовой документации**: Создание тест-кейсов, тест-планов, тестовых сценариев.
    
2. **Выполнение тестов**: Проведение ручного тестирования, включая функциональные тесты, регрессионные тесты, тесты на совместимость и производительность.
    
3. **Документирование дефектов**: Регистрация найденных ошибок в баг-трекинговых системах (например, Jira, Bugzilla).
    
4. **Обратная связь с разработчиками**: Взаимодействие с разработчиками для выяснения причин ошибок и их устранения.
    
5. **Ручное тестирование**: Проверка функциональности системы, юзабилити, тестирование пользовательского интерфейса.
    
6. **Поддержка автоматизированных тестов**: В некоторых случаях тестировщик может участвовать в поддержке автоматизированных тестов или написании простых скриптов.
    

#### Обязанности **QA-инженера**:

1. **Анализ требований**: Применение различных техник для оценки и понимания требований к проекту с целью создания тестовой стратегии.
    
2. **Создание и настройка тестовых сред**: QA-инженер может настроить окружение для тестирования, в том числе различные конфигурации серверов, базы данных, виртуальные машины.
    
3. **Автоматизация тестов**: Написание и настройка автоматизированных тестов для повторяющихся процессов (например, с использованием Selenium, JUnit, TestNG).
    
4. **Планирование тестирования**: Составление тест-планов и выбор методов тестирования.
    
5. **Использование инструментов для мониторинга качества**: Использование инструментов для отслеживания и управления качеством, таких как CI/CD системы, системы управления дефектами.
    
6. **Работа с метриками**: Сбор и анализ метрик, таких как покрытие кода, время выполнения тестов, количество дефектов, и их анализ с целью оптимизации процесса тестирования.
    

#### Чем отличается QA-тестировщик от QA-инженера:

- **QA-тестировщик** обычно фокусируется на **ручном тестировании**, выполняя тесты, описывая ошибки и обеспечивая базовое качество продукта.
    
- **QA-инженер** имеет более широкий спектр обязанностей, включая **автоматизацию тестов**, **разработку тестовых стратегий**, создание **тестовых сред** и использование различных **инструментов для улучшения качества продукта**. Это более техническая роль с акцентом на оптимизацию и автоматизацию процессов тестирования.
    

---

### 7. Принципы тестирования.

Принципы тестирования являются основой для проведения качественного тестирования и включают в себя следующее:

1. **Тестирование зависит от требований**: Тестирование должно быть основано на четких требованиях, чтобы убедиться, что система выполняет нужные функции.
    
2. **Тестирование не может доказать отсутствие дефектов**: Тестирование может только обнаружить ошибки, но не гарантировать их полное отсутствие.
    
3. **Раннее тестирование**: Тестирование должно начинаться как можно раньше в процессе разработки, чтобы выявить дефекты на ранних стадиях.
    
4. **Избыточность тестов**: Проведение различных типов тестов помогает охватить весь спектр возможных дефектов, включая функциональные, производительные, безопасностные и другие.
    
5. **Концентрация на рисках**: Риски и приоритеты должны быть определены на основе анализа важности частей системы.
    
6. **Повторяемость тестов**: Тесты должны быть повторяемыми, чтобы их можно было выполнить несколько раз с одинаковым результатом.
    
7. **Тестирование на основе фактов**: Все дефекты и результаты тестов должны быть задокументированы и доказуемы.
    
8. **Тестирование должно быть целенаправленным**: Тесты должны быть спланированы так, чтобы обеспечить максимальное покрытие и эффективность.
    

---

### 8. Место процесса тестирования в различных моделях разработки ПО.

Процесс тестирования занимает важное место в разных моделях разработки ПО и интегрируется с остальными этапами. Рассмотрим несколько популярных моделей:

1. **Каскадная модель (Waterfall)**:
    
    - Тестирование начинается после завершения этапа разработки. Тестировщики работают с готовым продуктом, что означает более позднее выявление дефектов, а следовательно, более высокие затраты на исправление.
        
2. **Итеративная модель (Iterative)**:
    
    - В этой модели тестирование начинается на ранних стадиях, и тесты выполняются после каждой итерации. Это позволяет быстрее выявить проблемы и исправить их до завершения разработки.
        
3. **Agile (Гибкая разработка)**:
    
    - В Agile тестирование является неотъемлемой частью процесса разработки, выполняется одновременно с кодированием и включает тестирование на каждой стадии (например, Unit Testing, интеграционное тестирование, функциональное тестирование). Тестирование выполняется итеративно, что позволяет быстро получать обратную связь и улучшать продукт.
        
4. **DevOps и CI/CD**:
    
    - В DevOps и CI/CD тестирование интегрируется в процесс непрерывной интеграции и доставки, что позволяет тестировать ПО на каждом этапе его разработки и автоматизировать выполнение тестов.
        

Таким образом, тестирование всегда тесно связано с процессом разработки, и его место в каждой модели зависит от структуры и этапов этой модели.

---

### 9. Жизненный цикл тестирования.

Жизненный цикл тестирования — это процесс, который охватывает все этапы тестирования ПО, начиная с планирования и заканчивая анализом результатов. Основные этапы жизненного цикла тестирования:

1. **Планирование тестирования**:
    
    - Определение целей и задач тестирования, выбор подхода, стратегии и методов тестирования, составление тест-плана.
        
2. **Анализ требований**:
    
    - Изучение и анализ требований к ПО, чтобы подготовить соответствующие тестовые сценарии и тест-кейсы.
        
3. **Проектирование тестов**:
    
    - Разработка тест-кейсов, тестовых данных, подготовка тестовых сред.
        
4. **Реализация тестов**:
    
    - Написание и выполнение тестов, как вручную, так и с использованием автоматизации.
        
5. **Выполнение тестов**:
    
    - Фактическое выполнение тестов, сбор результатов и обнаружение дефектов.
        
6. **Регистрация дефектов**:
    
    - Отчетность о найденных дефектах с детальной информацией для их исправления.
        
7. **Заключение**:
    
    - Оценка выполненных тестов, анализ полученных результатов и составление отчетов о тестировании. Принятие решения о готовности продукта к релизу или необходимости доработки.
        
8. **Поддержка тестов**:
    
    - Модификация и обновление тестов в процессе изменения требований или исправления дефектов.
        

Жизненный цикл тестирования помогает организовать тестовый процесс и гарантировать, что все этапы разработки продукта будут протестированы и проверены на качество.

### 10. Какие работы входят в этап планирования тестирования ПО?

Этап планирования тестирования является критически важным для успешного проведения тестирования. Он включает в себя несколько ключевых шагов:

1. **Определение целей и задач тестирования**: Уточнение, что необходимо проверить в программном продукте (функциональность, производительность, безопасность и т.д.).
    
2. **Анализ требований**: Проверка документации на наличие четких, полных и тестируемых требований. Это поможет сформулировать, что именно необходимо тестировать.
    
3. **Выбор подхода к тестированию**: Определение, какие типы тестов будут использованы (например, функциональные, регрессионные, нагрузочные тесты и т.д.).
    
4. **Определение стратегии тестирования**: Формулировка методов и подходов для тестирования (например, использование ручного тестирования, автоматизации, использование тестов на основе черного ящика или белого ящика).
    
5. **Разработка тестового плана**: Создание подробного тестового плана, который включает в себя:
    
    - Описание области тестирования
        
    - Параметры тестирования (что будет тестироваться)
        
    - Календарь и график проведения тестов
        
    - Ресурсы, необходимые для тестирования (оборудование, программное обеспечение, человеческие ресурсы)
        
    - Оценка рисков и определение методов минимизации этих рисков
        
6. **Подготовка тестовой среды**: Убедитесь, что у вас есть доступ к нужной инфраструктуре, программному обеспечению, средам разработки и тестирования.
    
7. **Оценка ресурсов**: Определение необходимых ресурсов для тестирования, включая оборудование, программные средства, специалисты и время.
    
8. **Определение критериев начала и окончания тестирования**: Установка четких критериев для того, чтобы тестирование могло начаться и завершиться успешно.
    
9. **Разработка критериев оценки качества**: Установление критериев, по которым будет определяться успешность выполнения тестирования и качество продукта.
    

---

### 11. Как проводят тестирование требований?

**Тестирование требований** проводится с целью проверки их полноты, ясности и реализуемости, а также того, насколько они соответствуют ожиданиям и потребностям пользователей. Основные шаги при тестировании требований:

1. **Проверка полноты**: Все необходимые требования для проекта должны быть задокументированы. Тестировщик проверяет, что ни одно требование не пропущено, и что все аспекты системы описаны в документации.
    
2. **Проверка ясности**: Требования должны быть четко сформулированы и понятны всем участникам проекта. Необходимо устранить двусмысленности и неясности в текстах требований.
    
3. **Проверка достижимости**: Оценка того, можно ли выполнить требования в рамках текущих ограничений (время, бюджет, ресурсы). Тестировщик проверяет, могут ли разработчики фактически реализовать требования.
    
4. **Проверка тестируемости**: Все требования должны быть тестируемыми. Тестировщик проверяет, можно ли определить успешное выполнение требования с помощью тестов.
    
5. **Проверка согласованности**: Требования не должны противоречить друг другу. Они должны быть согласованы с заказчиком и другими членами команды.
    
6. **Проверка приоритетности**: Необходимо определить, какие требования являются наиболее критичными для успеха проекта. Требования должны быть отсортированы по важности и приоритетности.
    

---

### 12. Критерии входа в тестирование. Критерии выхода.

#### **Критерии входа в тестирование** — это условия, которые должны быть выполнены, чтобы тестирование могло начаться:

1. **Готовность тестовой среды**: Среда тестирования должна быть подготовлена (оборудование, программное обеспечение, доступы).
    
2. **Готовность тестовых данных**: Данные для тестирования должны быть подготовлены.
    
3. **Завершение этапа разработки**: Код, который будет тестироваться, должен быть готов и передан в тестирование.
    
4. **Наличие требований и документации**: Требования должны быть четко сформулированы и документированы.
    
5. **Наличие тестовых сценариев и планов**: Все тестовые сценарии должны быть подготовлены и утверждены.
    
6. **Доступность необходимых ресурсов**: Все человеческие и технические ресурсы должны быть доступны для выполнения тестирования.
    

#### **Критерии выхода из тестирования** — это условия, при которых тестирование можно завершить:

1. **Все тесты выполнены**: Все запланированные тесты были выполнены, включая положительные и отрицательные сценарии.
    
2. **Тесты прошли успешно**: Все критические баги были устранены, и все важные требования были проверены.
    
3. **Уровень дефектов в пределах нормы**: Нет критических или высоких дефектов, которые бы мешали релизу.
    
4. **Документация завершена**: Все отчеты о тестировании подготовлены и обсуждены с заинтересованными сторонами.
    
5. **Согласование с заинтересованными сторонами**: Результаты тестирования были рассмотрены заказчиком или другими ключевыми участниками проекта, и они согласны с готовностью продукта к релизу.
    

---

### 13. Классификация тестирования.

Тестирование программного обеспечения можно классифицировать по различным критериям, таким как **тип тестирования**, **уровень тестирования**, **стратегия тестирования** и **инструменты**.

#### Основные виды тестирования:

1. **По типу**:
    
    - **Функциональное тестирование**: Проверяет, выполняет ли система заявленные функции.
        
    - **Нефункциональное тестирование**: Включает тесты на производительность, безопасность, удобство использования и другие аспекты.
        
    - **Ручное тестирование**: Тестирование, выполняемое вручную тестировщиками.
        
    - **Автоматизированное тестирование**: Тестирование, которое выполняется с использованием автоматизированных скриптов.
        
2. **По уровню**:
    
    - **Модульное тестирование (Unit Testing)**: Тестирование отдельных компонентов системы.
        
    - **Интеграционное тестирование (Integration Testing)**: Тестирование взаимодействия компонентов системы.
        
    - **Системное тестирование (System Testing)**: Тестирование всей системы в целом.
        
    - **Приемочное тестирование (Acceptance Testing)**: Проверка системы на соответствие бизнес- требованиям заказчика.
        
3. **По стратегии**:
    
    - **Черный ящик (Black Box Testing)**: Тестирование без знания внутренней реализации системы.
        
    - **Белый ящик (White Box Testing)**: Тестирование с полным знанием кода и структуры системы.
        
4. **По объекту**:
    
    - **Тестирование на основе требований (Requirement-based Testing)**: Основывается на проверке выполнения требований.
        
    - **Тестирование на основе рисков (Risk-based Testing)**: Проверяет наиболее рисковые части системы.
        

---

### 14. Уровни тестирования. Пирамида тестирования. Что показывает пирамида тестирования.

**Уровни тестирования** описывают, на каком уровне системы проводятся тесты. Они включают в себя:

1. **Модульное тестирование (Unit Testing)**: Проверка отдельных функций или компонентов программы.
    
2. **Интеграционное тестирование (Integration Testing)**: Проверка взаимодействия между модулями.
    
3. **Системное тестирование (System Testing)**: Проверка всего приложения в целом.
    
4. **Приемочное тестирование (Acceptance Testing)**: Проверка готовности системы к внедрению и соответствие требованиям заказчика.
    

#### **Пирамида тестирования** — это концепция, которая описывает баланс между различными уровнями тестирования:

- **Внизу** пирамиды: большое количество **модульных тестов** (Unit tests), которые автоматизированы и выполняются быстро. Это основа тестирования, которая должна покрывать все важные части системы.
    
- **В середине** пирамиды: **интеграционные тесты**, которые проверяют взаимодействие между компонентами, но их меньше, чем модульных тестов.
    
- **Верх пирамиды**: **системные и приемочные тесты**, которые часто являются ручными, более сложными и требуют больше времени и ресурсов.
    

Пирамида тестирования помогает поддерживать баланс между автоматизацией и качеством покрытия системы на разных уровнях, позволяя добиться оптимального сочетания скорости и надежности тестирования.

### 15. Тест-кейс, его особенности. Структура и атрибуты тест-кейса.

**Тест-кейс** — это документ, который описывает набор шагов для выполнения теста, цели тестирования, а также ожидаемые результаты для проверки, соответствует ли система заданным требованиям.

#### Особенности тест-кейса:

- **Повторяемость**: Тест-кейс должен быть таким, чтобы его можно было повторить в любой момент времени.
    
- **Понятность**: Тест-кейс должен быть понятен другим участникам команды, включая разработчиков и других тестировщиков.
    
- **Полнота**: В тест-кейсе должны быть указаны все важные шаги для тестирования.
    
- **Документированность**: Каждый тест-кейс должен быть документирован, чтобы его можно было использовать в будущем для тестирования аналогичных функций.
    

#### Структура тест-кейса:

1. **Идентификатор теста (ID)**: Уникальный идентификатор теста.
    
2. **Название теста**: Краткое описание цели теста.
    
3. **Описание теста**: Подробное описание того, что проверяется этим тестом.
    
4. **Предусловия**: Условия, которые должны быть выполнены до начала теста (например, данные должны быть подготовлены, система должна быть настроена).
    
5. **Шаги для выполнения**: Список шагов, которые необходимо выполнить для проведения теста.
    
6. **Ожидаемый результат**: Ожидаемое поведение системы при выполнении шагов теста.
    
7. **Фактический результат**: Результат, который был получен при выполнении теста.
    
8. **Статус**: Указывает, прошел ли тест (например, Passed, Failed, Blocked).
    
9. **Ответственный**: Лицо, которое проводило тестирование.
    
10. **Дата выполнения**: Когда был выполнен тест.
    

#### Атрибуты тест-кейса:

- **Тип теста** (например, функциональный, регрессионный).
    
- **Приоритет** (например, высокий, средний, низкий).
    
- **Уровень тестирования** (например, модульное, интеграционное, системное тестирование).
    
- **Теги или категории** (например, UI, безопасность, производительность).
    

---

### 16. Тест-дизайн. Основные техники тест-дизайна. Цель техник тест-дизайна.

**Тест-дизайн** — это процесс создания тестов на основе анализа требований и специфики приложения. Он включает в себя разработку тест-кейсов с использованием различных техник, чтобы обеспечить покрытие системы и эффективное тестирование.

#### Основные техники тест-дизайна:

1. **Техника черного ящика** (Black-box testing): Тестирование без знания внутренней структуры приложения. Тестировщик проверяет функциональность приложения, не учитывая, как она реализована.
    
2. **Техника белого ящика** (White-box testing): Тестирование с полным знанием внутренней структуры кода. Это включает проверку покрытия кода, логики программных путей и условий.
    
3. **Тестирование на основе риска**: Тесты фокусируются на наиболее рисковых частях приложения, которые имеют наибольшие шансы на сбой.
    
4. **Тестирование на основе требований**: Создание тестов, основанных на формализованных требованиях и спецификациях.
    

#### Цель техник тест-дизайна:

- **Обеспечение полного покрытия**: Все функциональные и нефункциональные требования должны быть протестированы.
    
- **Эффективность тестирования**: Уменьшение избыточности и дублирования тестов.
    
- **Выявление дефектов на ранних стадиях**: Поиск дефектов как на уровне компонентов, так и на уровне всей системы.
    
- **Оптимизация тестов**: Сокращение времени и ресурсов, затрачиваемых на тестирование, при сохранении высокого уровня качества.
    

---

### 17. Техники тест-дизайна. Классы эквивалентности и граничные значения.

#### 1. **Классы эквивалентности**:

**Классы эквивалентности** — это группы входных данных, которые могут быть обработаны одинаково, т.е. они вызывают однотипное поведение системы. Идея заключается в том, что если система правильно обрабатывает данные из одного класса, она будет корректно работать и с другими данными этого же класса.

- **Типы классов эквивалентности**:
    
    - **Положительные классы эквивалентности**: Данные, которые должны быть корректно обработаны системой.
        
    - **Отрицательные классы эквивалентности**: Данные, которые не должны быть приняты системой, например, некорректный формат ввода.
        

**Пример**:  
Для поля ввода возраста:

- Положительные классы: 18-100 лет.
    
- Отрицательные классы: -1, 0, 101.
    

#### 2. **Граничные значения**:

**Граничные значения** — это метод тестирования, при котором акцент делается на проверку крайних значений классов эквивалентности. Это связано с тем, что многие ошибки возникают на границах диапазонов.

- **Пример**:  
    Для возраста 18-100 лет:
    
    - Граничные значения: 17 (меньше минимального значения), 18 (минимальное значение), 100 (максимальное значение), 101 (больше максимального значения).
        

---

### 18. Техники тест-дизайна. Таблица решений. Таблица состояний.

#### 1. **Таблица решений**:

**Таблица решений** используется для моделирования логики принятия решений в системе. Она помогает организовать тестирование всех возможных комбинаций условий и действий.

- **Пример**:  
    Если система имеет два условия (например, "Пользователь авторизован" и "Аккаунт активен"), то таблица решений может выглядеть следующим образом:
    

|Условие 1 (Авторизован)|Условие 2 (Активен)|Действие|
|---|---|---|
|True|True|Доступ разрешен|
|True|False|Ошибка|
|False|True|Ошибка|
|False|False|Ошибка|

#### 2. **Таблица состояний**:

**Таблица состояний** используется для тестирования приложений, которые могут находиться в различных состояниях, и для которых действия зависят от текущего состояния системы. Таблица позволяет отслеживать переходы между состояниями.

- **Пример**:  
    Для системы с заказами:
    

| Состояние       | Действие        | Новое состояние |     |
| --------------- | --------------- | --------------- | --- |
| Заказ принят    | Отменить заказ  | Заказ отменен   |     |
| Заказ принят    | Отправить заказ | Заказ отправлен |     |
| Заказ отправлен | Доставить заказ | Заказ доставлен |     |
| Заказ доставлен | Поверить заказ  | Заказ завершен  |     |

---

### 19. Техники тест-дизайна. Попарное тестирование.

**Попарное тестирование** (Pairwise testing) — это методика, при которой тестируются все возможные пары значений входных параметров. Этот подход использует принцип, что большинство дефектов связано с взаимодействием только двух факторов, а не с их комбинациями.

#### Преимущества попарного тестирования:

- **Снижение числа тестов**: Попарное тестирование позволяет покрыть все возможные комбинации двух параметров с минимальным количеством тестов.
    
- **Экономия времени**: Сокращение числа тестов без потери качества покрытия.
    

**Пример**:  
Если система принимает два параметра:

- **Цвет**: Красный, Зеленый, Синий
    
- **Размер**: Малый, Средний, Большой
    

То попарное тестирование позволит протестировать все возможные пары значений этих параметров, что даст 9 уникальных тестов.

|Цвет|Размер|
|---|---|
|Красный|Малый|
|Красный|Средний|
|Красный|Большой|
|Зеленый|Малый|
|Зеленый|Средний|
|Зеленый|Большой|
|Синий|Малый|
|Синий|Средний|
|Синий|Большой|

Таким образом, попарное тестирование помогает эффективно покрыть все возможные взаимодействия параметров при минимизации количества тестов.

Минимизация в **попарном тестировании** достигается за счет того, что мы фокусируемся только на проверке всех возможных **пар значений** для входных параметров системы. Вместо того чтобы проверять все возможные комбинации значений всех параметров (что может быть крайне трудоемким и ресурсоемким процессом), мы тестируем только те комбинации, где параметры взаимодействуют между собой попарно.

#### Как это работает:

1. **Все возможные пары значений**: В попарном тестировании проверяются **все возможные пары значений** для разных параметров. Например, если есть три параметра (цвет, размер, форма) и для каждого параметра несколько возможных значений, то мы будем тестировать все возможные пары между этими параметрами.
    
2. **Исключение избыточных тестов**: Если вы проверяете все комбинации для каждого из параметров, вы в конечном итоге получите экспоненциальный рост числа тестов (особенно если количество параметров и значений велико). Попарное тестирование позволяет существенно сократить количество тестов, исключив избыточные комбинации, которые не обязательно будут влиять на работу системы.
    
3. **Пример:**
    
    Допустим, у нас есть 3 параметра с разными значениями:
    
    - **Цвет**: Красный, Зеленый, Синий
        
    - **Размер**: Малый, Средний, Большой
        
    - **Форма**: Круг, Квадрат
        
    
    Без минимизации, для проверки всех возможных комбинаций значений этих параметров потребуется **3 × 3 × 2 = 18 тестов** (все возможные комбинации трех параметров).
    
    Однако, в попарном тестировании мы будем проверять **все возможные пары значений** (цвет-размер, цвет-форма, размер-форма), что приведет к **минимальному набору тестов**, охватывающему все взаимодействия.
    
    В случае попарного тестирования комбинации могут быть следующими:
    
    |Цвет|Размер|Форма|
    |---|---|---|
    |Красный|Малый|Круг|
    |Красный|Средний|Квадрат|
    |Красный|Большой|Квадрат|
    |Зеленый|Малый|Квадрат|
    |Зеленый|Средний|Круг|
    |Синий|Средний|Квадрат|
    
    Это приведет к **6 тестам** вместо 18, при этом все возможные пары значений протестированы.
    
4. **Алгоритмы для минимизации**: Существует ряд алгоритмов и инструментов (например, **Pairwise** или **PICT**), которые могут автоматически генерировать тестовые случаи, минимизируя количество тестов, сохраняя при этом покрытие всех возможных пар значений.
    
5. **Как минимизация помогает**:
    
    - Сокращение количества тестов без потери качества покрытия.
        
    - Экономия времени на проведение тестов, так как уменьшается их общее количество.
        
    - Снижение затрат на ресурсы, так как для каждого набора значений проверяются только пары, которые наиболее вероятно могут вызывать проблемы.
        

#### Вывод:

Попарное тестирование минимизирует количество тестов, проверяя только все возможные взаимодействия между двумя параметрами, а не все возможные комбинации значений всех параметров. Это позволяет достичь оптимального покрытия системы при значительном сокращении времени и ресурсов, необходимых для тестирования.

### 20. Функциональное тестирование. Виды функционального тестирования.

**Функциональное тестирование** — это тип тестирования, при котором проверяется, выполняет ли система или ее компонент функции, предусмотренные требованиями или спецификациями. Оно фокусируется на том, чтобы проверить, что продукт работает так, как это предусмотрено функциональными требованиями.

#### Виды функционального тестирования:

1. **Тестирование по требованиям (Requirement-based testing)**:
    
    - Тестирование, при котором тесты создаются на основе требований к функциональности системы. Все требования должны быть покрыты тестами.
        
2. **Тестирование на основе спецификаций (Specification-based testing)**:
    
    - Тестирование, основанное на документации, которая описывает функциональные требования, без учета внутренней реализации программы.
        
3. **Интерфейсное тестирование (Interface testing)**:
    
    - Проверка взаимодействий между различными модулями или компонентами системы для обеспечения корректности работы интерфейсов.
        
4. **Регрессионное тестирование (Regression testing)**:
    
    - Тестирование, направленное на проверку того, что изменения в коде не нарушили функциональность, которая ранее работала корректно.
        
5. **Приемочное тестирование (Acceptance testing)**:
    
    - Проверка, удовлетворяет ли система всем функциональным требованиям и готова ли она к использованию конечными пользователями.
        
6. **Системное тестирование (System testing)**:
    
    - Комплексное тестирование всей системы, которое охватывает все функциональные аспекты приложения, включая взаимодействие с другими системами.
        

---

### 21. Сценарное и исследовательское тестирование. Отличия. Плюсы и минусы.

**Сценарное тестирование** и **исследовательское тестирование** — два популярных подхода в тестировании, отличающихся в методологии и подходах к созданию тестов.

#### Сценарное тестирование:

- **Определение**: В сценарном тестировании тестировщики следуют заранее подготовленным **тест-кейсам** или **сценариям**, которые описывают последовательность действий и ожидаемые результаты.
    
    **Плюсы**:
    
    - Хорошо структурированное и повторяемое тестирование.
        
    - Обеспечивает полный охват тестируемых функций.
        
    - Позволяет легко измерить покрытие и результативность тестов.
        
    
    **Минусы**:
    
    - Ограниченность в исследовании непредвиденных дефектов.
        
    - Может не выявить ошибки, которые не были учтены в тест-кейсах.
        

#### Исследовательское тестирование:

- **Определение**: Это более **гибкий** подход, при котором тестировщик исследует продукт без заранее подготовленных сценариев. В процессе тестирования он самостоятельно решает, какие области программы проверить, основываясь на опыте и интуиции.
    
    **Плюсы**:
    
    - Позволяет выявлять скрытые и неожиданные дефекты.
        
    - Гибкость в тестировании, позволяющая тестировщику адаптироваться к изменениям в приложении.
        
    - Более креативный подход к тестированию.
        
    
    **Минусы**:
    
    - Меньшая документированность и возможность контроля процесса.
        
    - Может быть сложно измерить покрытие и результативность тестирования.
        

**Отличия**:

- **Сценарное тестирование** основано на следовании заранее подготовленным тестам и сценариям.
    
- **Исследовательское тестирование** не требует заранее подготовленных тестов, и тестировщик исследует продукт с максимальной гибкостью.
    

---

### 22. Туры в исследовательском тестировании. «Районы» приложения. Примеры туров.

#### Туристическая метафора
  
Представьте себе типичного туриста, который посещает какой-нибудь туристический город. Здесь есть что посмотреть. Здесь есть что поделать. Да начнется трудная «работа»! То же и с тест-инженерами, которые нацелены максимально полно исследовать свой город – программный продукт.  
  
Встает множество вопросов. Какой транспорт взять? Как уложиться во времени? Как проложить сквозной маршрут? Как вести себя при отсутствии хорошего места для селфи? Нужно ли разбираться с этим самому или звать полицейского?  
  
Стратегия и цели. Если они отсутствуют, лучше сидеть дома. Цели существенно определяют план туриста: время и места. И они будут совершенно разные, например, для моряков, которые полгода были в плавании, и студентов… Ну, может пример и не лучший. данных или при потере соединения с сервером.
#### 1. Бизнес-районы
  
Это места, где «делается бизнес». Они начинаются с запуска кода и до завершения его работы. В них расположены функции, ради которых пользователи и используют данное приложение. Это «задняя стенка коробки» (читай – приложения), которая является главной при демонстрации коммерческой ценности продукта, а также код, который это поддерживает.
##### Тур «после работы»
После денежной активности приложения, оно все еще продолжает работу. Это поддержка задач, архивация данных и файлов. Это может быть автоматическим процессом, но его также можно выполнять принудительно. Данный тур напоминает нам делать это.  
  
Вариация тура – утреннее включение. Задача – тестирование начальных процедур и скриптов.  
##### Тур уборщика
Уборщики – это такие ребята, которые знают округу даже лучше, чем здесь живущие или здешние полисмены. День за днем, улица за улицей.  
  
Мы можем наметить места для методичной проверки интерфейса: экран за экраном, диалог за диалогом (преимущественно, по короткому пути) без детального тестирования. Только очевидные места.  
  
Указанный тур включает выбор цели (все меню, ошибки, диалоговые окна, к примеру) и посещение каждой из них наиболее коротким путем.
#### 2. Исторические районы
  
Это излюбленные туристами исторические места, места, окруженные историей. Сюда включены «legacy» код и функции и фичи, которые исторически содержали большое количество ошибок. «Legacy» код зачастую плохо понятен. Его использование и изменение подразумевает большое количество предположений. Именно на этом компоненте и сосредотачивается данный тур.  
#### 3. Туристические районы
  
Во многих городах есть места, которые интересны только туристам и пользователям-новичкам. Местные ребята избегают таких мест, поскольку им там тесно. То есть (прим. для ПО) пользователи, которые уже имеют опыт взаимодействия с приложением, подобные функции почти не используют.

##### Тур супермодели
Для этого тура мыслите поверхностно, не заходите дальше того, что снаружи. Примите уроки, которым нас учит современность. Этот тур не о функциях или чем-то существенном, а о том, как приложение выглядит и какое первое впечатление производит.  
  
Сосредоточьтесь на интерфейсе. Он хорош? Хорошо выполнен? Если я делаю изменения, отображается ли это на нем? Происходит ли это корректно и не остаются ли какие-либо артефакты на экране? Все ли на своем месте? Нарушает ли он какие-либо требования удобства или стандарты?  
  
Возможно, к этому не стоит и прикасаться, но какой же чертовски хороший вид.   
##### Тур «тестируй одно, другое – бесплатно»
Этот тур для того, чтобы протестировать множественный запуск приложения одновременно. Запустите свое приложение, а потом еще раз, и еще. А теперь используйте фичи, которые относятся к памяти или дисковому пространству. Заставьте все копии приложения сделать что-то с тем же файлом или передачей каких-либо данных.
#### 4. Развлекательные районы
  
После изучения исторических и туристических мест, порой необходимо предоставить себе отдых, немного развлечься. В ПО также наличествует что-то похожее – дополнительный функционал. И нужно его проверить.  
#### 5. Районы отелей
  
В каждом туристическом городе должны быть места, где можно отдохнуть, восстановить силы, переждать непогоду. Но вот ПО в моменты отдыха пользователя совсем не отдыхает. И хорошо бы проверить что и как оно делает.  
#### 6. Захудалые районы
  
Это небезопасные район, которые, однако, для кое-кого представляют некоторый интерес. Там творятся плохие вещи, и, видимо, будет лучше не лезть туда. Всем, кроме тест-инженеров. Эти места должны быть протестированы, поскольку они могут содержать уязвимости продукта. (Возможные уязвимости)

---

### 23. Что такое ошибка (баг)? Типы ошибок

**Ошибка (баг)** — это дефект или неисправность в программе, когда она не выполняет свою задачу должным образом, не соответствует требованиям или приводит к неправильным результатам.

#### Типы ошибок:

1. **Функциональные ошибки**:
    
    - Ошибки, когда система не выполняет требуемую функцию или выполняет ее неправильно.
        
2. **Ошибки интерфейса**:
    
    - Проблемы с пользовательским интерфейсом, например, некорректно отображаемые кнопки, текст или элементы управления.
        
3. **Ошибки производительности**:
    
    - Когда система работает медленно или некорректно при большой нагрузке.
        
4. **Ошибки безопасности**:
    
    - Уязвимости, которые могут быть использованы для атаки на систему (например, SQL инъекции, XSS атаки).
        
5. **Ошибки совместимости**:
    
    - Проблемы, когда система не работает на определенных платформах, операционных системах или браузерах.
        
6. **Ошибки логики**:
    
    - Когда алгоритмы или процесс обработки данных неправильно реализованы (например, ошибка в расчетах или неправильная обработка данных).
        

---

### 24. Серьезность и приоритет ошибки (бага). Локализация. Жизненный цикл бага.

#### **Серьезность ошибки (Severity)**:

Серьезность определяет, насколько критична ошибка для функционирования системы. Обычно серьезность классифицируется следующим образом:

1. **Критическая (Critical)**: Ошибка полностью блокирует работу системы или критически влияет на её функциональность.
    
2. **Высокая (High)**: Ошибка вызывает серьезные проблемы в функциональности, но приложение в целом работает.
    
3. **Средняя (Medium)**: Ошибка влияет на функциональность, но есть обходные пути или способы избежать проблем.
    
4. **Низкая (Low)**: Ошибка не влияет на основную функциональность и имеет минимальное влияние на пользоватульский опыт (например, незначительные проблемы с отображением).
    

#### **Приоритет ошибки (Priority)**:

Приоритет определяет, насколько быстро ошибка должна быть исправлена. Он зависит от того, сколько времени потребуется для ее исправления, а также от бизнес-значимости.

1. **Высокий (High)**: Ошибка должна быть исправлена как можно скорее, так как она может препятствовать нормальному функционированию системы.
    
2. **Средний (Medium)**: Ошибка требует исправления, но не настолько срочно.
    
3. **Низкий (Low)**: Ошибка может быть исправлена в будущем или в следующем релизе.
    

#### **Локализация ошибки**:

Локализация ошибки — это определение местоположения проблемы в системе. Это может быть:

- **По коду**: Описание, в каком участке кода возникает ошибка.
    
- **По интерфейсу**: Указание, где именно в интерфейсе пользователя возникает проблема.
    
- **По функциональности**: Определение, какой именно функциональный модуль или компонент работает неправильно.
    

#### **Жизненный цикл бага**:

1. **Обнаружение**: Ошибка найдена тестировщиком или пользователем.
    
2. **Регистрация**: Ошибка регистрируется в системе отслеживания дефектов (например, Jira, Bugzilla).
    
3. **Классификация**: Ошибка получает приоритет и серьезность.
    
4. **Анализ**: Разработчики анализируют ошибку и выясняют ее причину.
    
5. **Исправление**: Разработчики исправляют ошибку.
    
6. **Тестирование**: Исправленный баг проверяется тестировщиками.
    
7. **Закрытие**: Ошибка закрывается, если она исправлена и протестирована.
    

Жизненный цикл бага помогает отслеживать и управлять дефектами в процессе разработки и тестирования программного обеспечения.

### 25. Отчет об ошибке (баг-репорт). Цель отчета. Атрибуты качественного баг-репорта.

**Отчет об ошибке (баг-репорт)** — это документ, который содержит детальное описание ошибки или дефекта, найденного в процессе тестирования программного обеспечения. Баг-репорт предоставляет разработчикам необходимую информацию для воспроизведения ошибки и её устранения.

#### Цель отчета:

- **Документирование дефекта**: Обеспечить четкую запись о дефекте, чтобы команда могла воспроизвести и исправить его.
    
- **Оповещение команды**: Сообщить разработчикам и заинтересованным сторонам о наличии ошибки.
    
- **Обеспечение отслеживания дефекта**: Помогает отслеживать статус дефекта, от его открытия до исправления.
    

#### Атрибуты качественного баг-репорта:

1. **Идентификатор (ID)**: Уникальный номер, который позволяет отслеживать дефект.
    
2. **Название/Краткое описание**: Краткое, но емкое описание проблемы.
    
3. **Описание**: Подробное описание ошибки, включая контекст, в котором она возникла.
    
4. **Шаги для воспроизведения**: Точные и понятные шаги, которые нужно выполнить, чтобы воспроизвести ошибку.
    
5. **Ожидаемый результат**: Что должно было произойти, если ошибка не была бы воспроизведена.
    
6. **Фактический результат**: Что произошло на самом деле при воспроизведении ошибки.
    
7. **Статус**: Текущий статус бага (например, новый, в процессе, исправлен).
    
8. **Серьезность (Severity)**: Оценка того, насколько критична ошибка для функциональности системы.
    
9. **Приоритет**: Определяет, насколько быстро ошибка должна быть исправлена.
    
10. **Окружение**: Уточнение условий, при которых ошибка возникла (операционная система, версия приложения, конфигурация устройства).
    
11. **Скриншоты/Логи**: Дополнительные файлы, которые могут помочь в воспроизведении или устранении ошибки.
    
12. **Ответственный**: Личность или команда, ответственная за исправление ошибки.
    

---

### 26. Отчет о результатах тестирования. Цель. Структура.

**Отчет о результатах тестирования** — это документ, который суммирует результаты всех проведенных тестов и предоставляет информацию о качестве продукта на основе выполненных тестов.

#### Цель отчета:

- **Представление результатов**: Оповещение заинтересованных сторон (менеджеров, заказчиков, разработчиков) о результатах тестирования.
    
- **Обоснование решения**: Помогает определить, готов ли продукт к релизу, на основе полученных результатов тестирования.
    
- **Оценка качества продукта**: Предоставление информации о качестве программного обеспечения на основе выполненных тестов.
    

#### Структура отчета о результатах тестирования:

1. **Введение**: Описание целей тестирования, контекста и тестируемых аспектов.
    
2. **Обзор тестирования**:
    
    - Перечень проведенных тестов.
        
    - Виды тестирования (например, функциональное, производственное, безопасность).
        
3. **Результаты тестирования**:
    
    - Описание успешных и неуспешных тестов.
        
    - Количество тестов, прошедших и не прошедших, с подробностями по каждому неудавшемуся тесту.
        
4. **Оценка дефектов**:
    
    - Обзор дефектов: их количество, приоритет, серьезность.
        
    - Статус дефектов (открыты, исправлены, в процессе и т.д.).
        
5. **Рекомендации**: Действия, которые нужно предпринять, исходя из результатов тестирования.
    
6. **Заключение**: Итоги тестирования, заключение о готовности продукта к релизу или необходимости доработок.
    

---

### 27. Автоматизированное тестирование. Плюсы. Минусы.

**Автоматизированное тестирование** — это использование специализированных инструментов и скриптов для выполнения тестов, вместо того, чтобы выполнять их вручную.

#### Плюсы:

1. **Скорость выполнения**: Автоматизированные тесты выполняются быстрее, чем вручную, особенно для повторяющихся тестов.
    
2. **Повторяемость**: Автоматические тесты могут быть повторно использованы для различных версий приложения, что снижает вероятность ошибок из-за человеческого фактора.
    
3. **Снижение затрат на ручное тестирование**: Особенно выгодно при частых релизах и необходимости тестирования большого объема.
    
4. **Повышение покрытия тестами**: Автоматизация позволяет охватить больше тестов и сэкономить время.
    
5. **Независимость от времени**: Автоматические тесты могут выполняться в любое время суток, что позволяет использовать время более эффективно.
    

#### Минусы:

1. **Высокие начальные затраты**: Разработка и поддержка автоматизированных тестов требуют значительных усилий и времени.
    
2. **Трудности в настройке**: Требуется подготовка инфраструктуры и инструментов для автоматизации.
    
3. **Не подходит для всех типов тестов**: Например, тестирование пользовательского интерфейса или исследовательское тестирование трудно автоматизировать.
    
4. **Обслуживание тестов**: Автоматические тесты требуют регулярного обновления при изменениях в приложении, что может быть затратно.
    

---

### 28. Цель автоматизированного тестирования. Какие тесты лучше подходят для автоматизации?

#### Цель автоматизированного тестирования:

Цель автоматизированного тестирования — это повышение эффективности тестирования, сокращение времени на выполнение тестов, улучшение покрытия тестами, а также снижение человеческой ошибки. Автоматизация особенно эффективна для проведения повторяющихся тестов и тестирования в условиях ограниченного времени, например, в процессе CI/CD (непрерывной интеграции и доставки).

#### Тесты, которые лучше всего подходят для автоматизации:

1. **Регрессионные тесты**: Тесты, которые проверяют, не нарушена ли функциональность после внесения изменений в код.
    
2. **Тесты на производительность**: Например, нагрузочные и стресс-тесты, которые требуют многократного выполнения с различной нагрузкой.
    
3. **Тесты на совместимость**: Когда нужно проверить работу приложения на различных платформах и конфигурациях.
    
4. **Тесты с большими объемами данных**: Проверка системы с большими объемами входных данных, что вручную может быть затруднительно.
    
5. **Тесты, выполняющиеся часто**: Например, на этапах разработки, когда необходимо проверять работу приложения после каждой сборки.
    

Автоматизация не подходит для всех типов тестирования, например, для **исследовательского тестирования** или **тестирования пользовательского интерфейса**, где важна гибкость и способность тестировщика адаптироваться к изменениям в приложении.

### 29. Процесс автоматизации тестирования

Процесс автоматизации тестирования включает несколько этапов, которые обеспечивают успешную интеграцию автоматизации в процесс тестирования и разработки программного обеспечения.

#### Этапы процесса автоматизации тестирования:

1. **Анализ и планирование**:
    
    - Определение целей автоматизации.
        
    - Выбор тестов для автоматизации (например, повторяющиеся, стабильные тесты, тесты регрессии).
        
    - Оценка стоимости и времени для разработки автоматизированных тестов.
        
2. **Выбор инструментов**:
    
    - Выбор подходящих инструментов автоматизации, которые соответствуют специфике проекта (например, Selenium для веб-приложений, JUnit или TestNG для написания тестов).
        
3. **Разработка тестов**:
    
    - Написание скриптов для автоматизированных тестов, например, с использованием выбранных инструментов и фреймворков.
        
    - Разработка тестовых данных и сценариев.
        
    - Интеграция тестов в процесс CI/CD.
        
4. **Запуск тестов**:
    
    - Выполнение автоматизированных тестов в заданной среде (локальной, тестовой или продакшн среде).
        
    - Проверка результатов тестов (успешных и неудачных тестов).
        
5. **Анализ результатов и отчетность**:
    
    - Генерация отчетов по результатам тестирования, анализ отклонений и ошибок.
        
    - Определение причин неудач и работа с командой для их исправления.
        
6. **Поддержка автоматизированных тестов**:
    
    - Регулярное обновление тестов в случае изменений в функциональности системы.
        
    - Поддержка тестовых данных, настройка тестовых сред.
        
7. **Интеграция в процесс CI/CD**:
    
    - Интеграция автоматизированных тестов в процесс непрерывной интеграции и доставки (CI/CD), что позволяет выполнять тесты при каждом изменении в коде или релизе.
        

---

### 30. Уровни автоматизированного тестирования. Фреймворки для каждого из этих уровней.

Автоматизированное тестирование делится на несколько уровней, каждый из которых имеет свои особенности и цели. Для каждого уровня существуют свои фреймворки и инструменты.

#### 1. **Модульное тестирование (Unit Testing)**:

- **Цель**: Проверка отдельных функций или методов. Это самый низкий уровень тестирования, где тестируются маленькие части кода, чтобы удостовериться в их правильности.
    
- **Фреймворки**:
    
    - **JUnit** (для Java)
        
    - **NUnit** (для .NET)
        
    - **pytest** (для Python)
        
    - **Mocha** (для JavaScript)
        

#### 2. **Интеграционное тестирование (Integration Testing)**:

- **Цель**: Проверка взаимодействия между модулями системы. Тестирование интеграции между различными компонентами или модулями.
    
- **Фреймворки**:
    
    - **Spring Test** (для Java)
        
    - **TestNG** (для Java)
        
    - **Jest** (для JavaScript)
        
    - **Postman** (для тестирования API)
        

#### 3. **Системное тестирование (System Testing)**:

- **Цель**: Тестирование всей системы или приложения в целом, чтобы проверить, как система работает как единое целое.
    
- **Фреймворки**:
    
    - **Selenium WebDriver** (для автоматизации тестов веб-интерфейса)
        
    - **Cypress** (для тестирования фронтенда)
        
    - **Appium** (для мобильных приложений)
        

#### 4. **Приемочное тестирование (Acceptance Testing)**:

- **Цель**: Проверка того, что продукт соответствует бизнес-требованиям и готов к использованию конечным пользователем.
    
- **Фреймворки**:
    
    - **Cucumber** (для поведения тестирования на основе Gherkin)
        
    - **SpecFlow** (для .NET)
        

#### 5. **Регрессионное тестирование (Regression Testing)**:

- **Цель**: Убедиться, что новые изменения в коде не сломали уже работающее приложение.
    
- **Фреймворки**:
    
    - **Selenium** (для автоматизации веб-приложений)
        
    - **TestComplete** (для тестирования на различных платформах)
        
    - **Katalon Studio** (универсальное решение для тестирования)
        

---

### 31. Подходы в UI автоматизации.

UI автоматизация включает в себя тестирование пользовательского интерфейса приложения с помощью автоматизированных тестов. Существует несколько подходов для автоматизации UI тестирования.

#### 1. **Использование фреймворков для UI тестирования**:

Один из основных подходов — использование фреймворков для автоматизации взаимодействий с элементами пользовательского интерфейса.

- **Selenium**: Один из самых популярных инструментов для автоматизации браузеров. Он позволяет записывать и воспроизводить действия пользователя на веб-страницах.
    
- **Cypress**: Еще один инструмент для автоматизации UI тестов, который предлагает большую скорость и простоту настройки по сравнению с Selenium, особенно для тестирования фронтенда.
    
- **Appium**: Инструмент для автоматизации тестирования мобильных приложений (Android и iOS).
    

#### 2. **Использование рекордеров**:

Рекордеры позволяют записывать действия пользователя (клики, ввод текста и другие взаимодействия) и автоматически генерировать тесты.

- **Selenium IDE**: Плагин для браузеров, который позволяет записывать и проигрывать тесты без необходимости написания кода.
    
- **Katalon Studio**: Инструмент с поддержкой записи тестов и их выполнения.
    

#### 3. **Ключевые особенности UI автоматизации**:

- **Поиск элементов**: На этом этапе автоматизированные тесты используют различные локаторы для поиска элементов на странице (например, ID, класс, XPath).
    
- **Взаимодействие с элементами**: Тесты симулируют действия пользователя, такие как клик по кнопке, ввод текста в поля ввода, прокрутка страницы и т.д.
    
- **Проверка результатов**: Автоматизированные тесты проверяют правильность отображения элементов, наличие нужных данных или правильность взаимодействий.
    

#### 4. **Преимущества и сложности UI автоматизации**:

- **Преимущества**:
    
    - Экономия времени на регрессионных тестах.
        
    - Повторяемость тестов.
        
    - Быстрое обнаружение дефектов.
        
- **Сложности**:
    
    - Потребность в регулярной поддержке тестов при изменении интерфейса.
        
    - Иногда сложно обеспечить стабильность тестов из-за динамичных изменений интерфейса.
        
    - Высокие начальные затраты на настройку автоматизации UI.
        

Таким образом, автоматизация UI тестирования позволяет ускорить процесс тестирования и повысить его эффективность, особенно в случаях повторных тестов или сложных приложений с многочисленными взаимодействиями.
### 32. Что такое Selenium и из чего состоит?

**Selenium** — это набор инструментов с открытым исходным кодом для автоматизации веб-приложений, позволяющий взаимодействовать с браузером через программный интерфейс (API). Selenium используется для тестирования веб-приложений, выполнения различных действий на веб-страницах (например, клики, ввод текста и т.д.) и имитации работы пользователей с веб-сайтами.

Selenium состоит из нескольких основных компонентов:

1. **Selenium WebDriver** — это интерфейс для взаимодействия с браузером. WebDriver позволяет управлять браузерами с помощью программного кода, эмулируя действия пользователя.
    
2. **Selenium Grid** — это инструмент для распределенной обработки тестов на различных машинах и браузерах, что ускоряет выполнение тестов.
    
3. **Selenium IDE** — это интегрированная среда разработки, которая позволяет записывать и воспроизводить действия в браузере без необходимости написания кода. Это более удобный инструмент для пользователей, не знакомых с программированием.
    
4. **Selenium RC (Remote Control)** — устаревшая версия, которая использовалась для удаленного тестирования, но была заменена WebDriver.
    

### 33. Что такое локатор Selenium? Какие есть типы локаторов?

**Локатор** в Selenium — это способ поиска элементов на веб-странице, с которыми можно взаимодействовать (например, кнопки, поля ввода и т.д.). Локаторы необходимы для того, чтобы WebDriver мог найти нужные элементы и выполнять с ними действия.

`By` — это класс в библиотеке Selenium, который используется для указания метода поиска элемента на веб-странице. В Selenium `By` служит как инструмент для создания различных локаторов (например, по ID, имени, CSS-селектору и т.д.), которые используются для нахождения элементов в DOM (Document Object Model) веб-страницы.

Существуют следующие типы локаторов в Selenium:

1. **ID** — поиск элемента по уникальному идентификатору HTML-элемента.
    
    ```java
    driver.findElement(By.id("element_id"));
    ```
    
2. **Name** — поиск элемента по атрибуту `name`.
    
    ```java
    driver.findElement(By.name("element_name"));
    ```
    
3. **Class Name** — поиск элемента по классу CSS.
    
    ```java
    driver.findElement(By.className("element_class"));
    ```
    
4. **Tag Name** — поиск элемента по тегу (например, `div`, `input`).
    
    ```java
    driver.findElement(By.tagName("input"));
    ```
    
5. **Link Text** — поиск элемента по полному тексту ссылки.
    
    ```java
    driver.findElement(By.linkText("Click here"));
    ```
    
6. **Partial Link Text** — поиск элемента по частичному тексту ссылки.
    
    ```java
    driver.findElement(By.partialLinkText("Click"));
    ```
    
7. **CSS Selector** — поиск элемента с помощью CSS-селектора.
    
    ```java
    driver.findElement(By.cssSelector(".element_class"));
    ```
    
8. **XPath** — поиск элемента с использованием выражений XPath.
    
    ```java
    driver.findElement(By.xpath("//div[@class='element_class']"));
    ```
    

### 34. В чем разница между командами `driver.findElement()` и `driver.findElements()`?

- **`driver.findElement()`** — метод, который ищет **первый** элемент на веб-странице, соответствующий заданному локатору. Если элемент не найден, он вызывает исключение `NoSuchElementException`.
    
    ```java
    WebElement element = driver.findElement(By.id("example"));
    ```
    
- **`driver.findElements()`** — метод, который ищет **все** элементы на веб-странице, соответствующие заданному локатору, и возвращает список (`List<WebElement>`). Если элементы не найдены, он возвращает пустой список, а не вызывает исключение.
    
    ```java
    List<WebElement> elements = driver.findElements(By.className("example_class"));
    ```
    

Таким образом, `findElement()` используется, когда ожидается только один элемент, а `findElements()` — когда нужно найти несколько элементов, соответствующих локатору.
### 35. Взаимодействие с веб-элементами в Selenium

В Selenium для взаимодействия с веб-элементами используются различные методы, которые позволяют выполнить действия, такие как клик, ввод текста, получение значений и другие манипуляции с элементами на веб-странице.

Основные методы для взаимодействия с веб-элементами:

1. **Клик на элемент**:
    
    ```java
    WebElement element = driver.findElement(By.id("submit_button"));
    element.click();
    ```
    
2. **Ввод текста в поле**:
    
    ```java
    WebElement inputField = driver.findElement(By.name("username"));
    inputField.sendKeys("myUsername");
    ```
    
3. **Очистка поля ввода**:
    
    ```java
    WebElement inputField = driver.findElement(By.name("username"));
    inputField.clear();
    ```
    
4. **Получение текста из элемента**:
    
    ```java
    WebElement element = driver.findElement(By.id("message"));
    String messageText = element.getText();
    ```
    
5. **Получение атрибутов элемента**:
    
    ```java
    WebElement element = driver.findElement(By.id("input_field"));
    String value = element.getAttribute("value");
    ```
    
6. **Получение значения состояния элемента (например, чекбокс)**:
    
    ```java
    WebElement checkbox = driver.findElement(By.id("agree"));
    boolean isChecked = checkbox.isSelected();
    ```
    
7. **Проверка видимости элемента**:
    
    ```java
    WebElement element = driver.findElement(By.id("element_id"));
    boolean isDisplayed = element.isDisplayed();
    ```
    

### 36. Взаимодействие с клавиатурой и мышью. ActionChains

Для более сложных взаимодействий с веб-страницей, таких как перемещение мыши, нажатие на несколько клавиш одновременно и другие, используется класс **`ActionChains`**. Это позволяет эмулировать сложные действия, которые не могут быть выполнены с помощью стандартных методов WebDriver.

Примеры использования `ActionChains`:

1. **Перемещение мыши на элемент**:
    
    ```java
    WebElement element = driver.findElement(By.id("menu"));
    Actions actions = new Actions(driver);
    actions.moveToElement(element).perform();
    ```
    
2. **Щелчок правой кнопкой мыши**:
    
    ```java
    WebElement element = driver.findElement(By.id("context_menu"));
    Actions actions = new Actions(driver);
    actions.contextClick(element).perform();
    ```
    
3. **Удержание клавиши и нажатие другой клавиши** (например, `Ctrl + A`):
    
    ```java
    WebElement inputField = driver.findElement(By.id("input_field"));
    Actions actions = new Actions(driver);
    actions.keyDown(Keys.CONTROL).sendKeys("a").keyUp(Keys.CONTROL).perform();
    ```
    
4. **Перетаскивание (drag and drop)**:
    
    ```java
    WebElement source = driver.findElement(By.id("source"));
    WebElement target = driver.findElement(By.id("target"));
    Actions actions = new Actions(driver);
    actions.dragAndDrop(source, target).perform();
    ```
    
5. **Нажатие на несколько клавиш одновременно** (например, `Shift + A`):
    
    ```java
    Actions actions = new Actions(driver);
    actions.keyDown(Keys.SHIFT).sendKeys("A").keyUp(Keys.SHIFT).perform();
    ```
    

### 37. Какие типы ожиданий доступны в Selenium WebDriver? Приведите примеры данных ожиданий. Каков приоритет их выполнения?

В Selenium WebDriver есть несколько типов ожиданий, которые помогают корректно взаимодействовать с элементами на веб-странице, не сталкиваясь с проблемой, когда элемент еще не загружен или не стал доступен для взаимодействия.

1. **Неявное ожидание (Implicit Wait)**:  
    Это ожидание, которое устанавливается на весь период работы с WebDriver. Оно заставляет WebDriver ожидать некоторое время до того, как выбрасывать исключение, если элемент не найден. Это ожидание применяется ко всем методам поиска элементов.
    
    Пример:
    
    ```java
    driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
    ```
    
2. **Явное ожидание (Explicit Wait)**:  
    Явное ожидание позволяет установить ожидания для конкретных элементов. Оно используется для того, чтобы дождаться определенных условий, например, когда элемент становится видимым или доступным для клика. Для этого используется класс `WebDriverWait` вместе с условием ожидания (`ExpectedConditions`).
    
    Пример:
    
    ```java
    WebDriverWait wait = new WebDriverWait(driver, 10);
    WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("submit_button")));
    ```
    
    Существует множество встроенных условий:
    
    - **visibilityOfElementLocated** — ждет, пока элемент станет видимым.
        
    - **elementToBeClickable** — ждет, пока элемент станет доступным для клика.
        
    - **presenceOfElementLocated** — ждет, пока элемент появится в DOM (не обязательно видимый).
        
    - **textToBePresentInElement** — ждет, пока в элементе появится определенный текст.
        
3. **Ожидание с использованием `Fluent Wait`**:  
    Fluent Wait является расширенной версией явного ожидания. Он позволяет настроить время ожидания, частоту проверки условия и игнорирование определенных исключений. Он полезен, если нужно контролировать частоту, с которой WebDriver будет проверять выполнение условия.
    
    Пример:
    
    ```java
    Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)
        .withTimeout(10, TimeUnit.SECONDS)
        .pollingEvery(1, TimeUnit.SECONDS)
        .ignoring(NoSuchElementException.class);
    
    WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("submit_button")));
    ```
    

### Приоритет выполнения ожиданий:

1. **Неявное ожидание** устанавливается сразу, и оно будет работать для всех последующих действий в тесте, если явно не указано другое ожидание. Оно действует на поиск элементов.
    
2. **Явное ожидание** используется только в тех местах, где необходимо ждать выполнения конкретных условий для элемента.
    
3. **Fluent Wait** предоставляет больше гибкости и используется, когда нужно настроить параметры проверки состояния элемента или обрабатывать исключения.
    

Приоритет выполнения будет зависеть от того, какой тип ожидания используется в коде. Например, если и явное, и неявное ожидание используются одновременно, то явное ожидание имеет более высокий приоритет в местах, где оно указано.


В Selenium существуют различные исключения, которые могут возникать в процессе работы с WebDriver. Они могут быть связаны с проблемами, такими как невозможность найти элемент, ожидание появления элемента, проблемы с взаимодействием с элементами и другие. Вот основные типы исключений в Selenium:

## 38. Какие исключения бывают в Selenium?
### 1. **NoSuchElementException**

- **Причина**: Это исключение возникает, когда WebDriver не может найти элемент, соответствующий заданному локатору.
    
- **Пример**:
    
    ```java
    WebElement element = driver.findElement(By.id("non_existing_element"));
    ```
    
- **Решение**: Убедитесь, что локатор корректен и элемент существует на странице. Также можно использовать явные или неявные ожидания для того, чтобы дождаться появления элемента.
    

### 2. **NoSuchWindowException**

- **Причина**: Возникает, когда WebDriver пытается взаимодействовать с окном, которое больше не существует или не может быть найдено.
    
- **Пример**:
    
    ```java
    driver.switchTo().window("non_existing_window");
    ```
    
- **Решение**: Проверьте, что окно существует, и что переход в правильное окно выполнен корректно.
    

### 3. **NoSuchFrameException**

- **Причина**: Это исключение возникает, если WebDriver не может найти фрейм (iframe) с заданным именем или индексом.
    
- **Пример**:
    
    ```java
    driver.switchTo().frame("non_existing_frame");
    ```
    
- **Решение**: Убедитесь, что фрейм с данным именем или индексом существует на странице.
    

### 4. **ElementNotVisibleException**

- **Причина**: Это исключение возникает, когда элемент найден, но он не видим на странице и не может быть с ним взаимодействовать (например, скрыт с помощью CSS).
    
- **Пример**:
    
    ```java
    WebElement element = driver.findElement(By.id("hidden_element"));
    element.click();  // Ошибка, если элемент скрыт
    ```
    
- **Решение**: Используйте явные ожидания, чтобы дождаться видимости элемента, или проверьте, не скрыт ли элемент.
    

### 5. **StaleElementReferenceException**

- **Причина**: Это исключение возникает, когда ссылка на элемент устарела, например, если страница была перезагружена или DOM был изменен после получения ссылки на элемент.
    
- **Пример**:
    
    ```java
    WebElement element = driver.findElement(By.id("some_element"));
    driver.navigate().refresh();
    element.click();  // Ошибка, так как элемент больше не существует в DOM
    ```
    
- **Решение**: После обновления страницы или изменений в DOM нужно заново получить ссылку на элемент.
    

### 6. **TimeoutException**

- **Причина**: Возникает, когда WebDriver не может выполнить действие (например, найти элемент или дождаться условия) в пределах заданного времени.
    
- **Пример**:
    
    ```java
    WebDriverWait wait = new WebDriverWait(driver, 5);
    wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("non_existing_element")));
    ```
    
- **Решение**: Увеличьте время ожидания или проверьте, что элемент доступен для взаимодействия в пределах ожидаемого времени.
    

### 7. **ElementNotSelectableException**

- **Причина**: Это исключение возникает, если элемент найден, но он не может быть выбран. Например, если элемент — это недоступный для выбора радиокнопка или чекбокс.
    
- **Пример**:
    
    ```java
    WebElement radioButton = driver.findElement(By.id("disabled_radio_button"));
    radioButton.click();  // Ошибка, если элемент не доступен для клика
    ```
    
- **Решение**: Убедитесь, что элемент доступен для взаимодействия.
    

### 8. **InvalidElementStateException**

- **Причина**: Это исключение возникает, когда элемент находится в недопустимом состоянии для выполнения действия. Например, попытка ввода текста в поле, которое не может быть отредактировано.
    
- **Пример**:
    
    ```java
    WebElement inputField = driver.findElement(By.id("readonly_input"));
    inputField.sendKeys("text");  // Ошибка, если поле только для чтения
    ```
    
- **Решение**: Убедитесь, что элемент доступен для редактирования перед выполнением действия.
    

### 9. **WebDriverException**

- **Причина**: Это общее исключение, которое возникает при проблемах с WebDriver. Оно может быть связано с ошибками в настройках браузера или проблемы с его драйверами.
    
- **Пример**:
    
    ```java
    driver.get("http://non_existent_site");
    ```
    
- **Решение**: Проверьте настройки и совместимость с браузером, а также наличие всех необходимых драйверов.
    

### 10. **UnsupportedCommandException**

- **Причина**: Это исключение возникает, если WebDriver пытается выполнить команду, которую не поддерживает драйвер.
    
- **Пример**:
    
    ```java
    driver.executeScript("unsupported command");
    ```
    
- **Решение**: Убедитесь, что используемая команда поддерживается для выбранного драйвера и браузера.
    

### 11. **ElementClickInterceptedException**

- **Причина**: Это исключение возникает, когда элемент, на который WebDriver пытается кликнуть, скрыт другим элементом, например, модальным окном или другим элементом, который блокирует клик.
    
- **Пример**:
    
    ```java
    WebElement button = driver.findElement(By.id("button"));
    button.click();  // Ошибка, если элемент перекрыт
    ```
    
- **Решение**: Используйте ожидания, чтобы дождаться исчезновения перекрывающего элемента, или прокрутите страницу так, чтобы элемент стал доступным.
    

### 12. **MoveTargetOutOfBoundsException**

- **Причина**: Это исключение возникает, когда попытка перемещения мыши выходит за пределы видимой области окна.
    
- **Пример**:
    
    ```java
    WebElement element = driver.findElement(By.id("menu"));
    Actions actions = new Actions(driver);
    actions.moveToElement(element, 1000, 1000).perform();  // Ошибка при выходе за пределы экрана
    ```
    
- **Решение**: Убедитесь, что координаты для перемещения находятся в пределах окна браузера.
    

### 13. **JavascriptException**

- **Причина**: Это исключение возникает, если выполняемый JavaScript-код не может быть выполнен корректно.
    
- **Пример**:
    
    ```java
    ((JavascriptExecutor) driver).executeScript("invalid code");
    ```
    
- **Решение**: Проверьте правильность JavaScript-кода.
    

---

Каждое из этих исключений связано с определенным видом проблемы или ошибки в процессе работы с Selenium WebDriver. Для их обработки можно использовать конструкцию try-catch, а также продумывать стратегию для предотвращения таких ошибок (например, используя ожидания, проверку условий и корректную обработку состояния элементов).

### 39. Модульное тестирование (Unit Testing). Определение. Цель.

**Модульное тестирование** (или **Unit Testing**) — это процесс тестирования отдельных частей программы (модулей) для проверки их корректности. Модульное тестирование фокусируется на проверке работы небольших, изолированных фрагментов кода, таких как функции или методы, чтобы убедиться, что они выполняются правильно.

**Цель** модульного тестирования:

- **Проверка функциональности**: Убедиться, что отдельные модули или функции работают так, как они должны.
    
- **Раннее обнаружение ошибок**: Найти ошибки на ранней стадии разработки, до того как они могут повлиять на более крупные компоненты системы.
    
- **Упрощение рефакторинга**: Позволяет вносить изменения в код без страха сломать другие части программы, так как модульные тесты помогают убедиться, что функциональность остается исправной после изменений.
    
- **Документация для других разработчиков**: Тесты могут служить документацией, показывающей, как должен работать конкретный модуль.
    

### 40. Процесс написания юнит-тестов. Структура юнит-теста. Паттерн ААА.

#### Процесс написания юнит-тестов:

1. **Определение требований**: Определите, что именно должен делать тестируемый метод или модуль.
    
2. **Написание тестов**: Напишите тесты для проверки функциональности метода. Тест должен проверять как ожидаемые, так и неожидаемые результаты.
    
3. **Запуск тестов**: Запустите тесты, чтобы проверить, что метод работает как ожидалось.
    
4. **Исправление ошибок**: Если тест не проходит, исправьте ошибки в коде и повторно запустите тесты.
    
5. **Рефакторинг**: После успешного прохождения всех тестов можно делать рефакторинг кода, не опасаясь, что изменится его функциональность.
    

#### Структура юнит-теста:

Юнит-тест состоит из нескольких ключевых частей:

1. **Подготовка данных** (Arrange): Настройка всех объектов, зависимостей и условий для выполнения теста.
    
2. **Выполнение тестируемого действия** (Act): Вызов тестируемой функции или метода.
    
3. **Проверка результата** (Assert): Сравнение фактического результата с ожидаемым.
    

#### Паттерн AAA:

Паттерн **AAA** (Arrange-Act-Assert) — это распространенная структура написания юнит-тестов, которая помогает организовать тесты логически и понятно:

- **Arrange (Подготовка)**: Подготовка всех необходимых данных, объектов, зависимостей и настроек.
    
- **Act (Действие)**: Вызов тестируемого метода или функции с заранее подготовленными данными.
    
- **Assert (Проверка)**: Проверка результата выполнения функции, чтобы убедиться, что он соответствует ожидаемому.
    

Пример теста в паттерне AAA:

```java
@Test
public void testSum() {
    // Arrange
    int a = 5;
    int b = 3;
    Calculator calculator = new Calculator();

    // Act
    int result = calculator.sum(a, b);

    // Assert
    assertEquals(8, result);
}
```

### 41. Назначение изоляции в юнит-тестировании. Виды тестовых заглушек. Примеры.

#### Назначение изоляции в юнит-тестировании:

**Изоляция** в юнит-тестировании важна, потому что она позволяет протестировать отдельные части кода независимо от других компонентов системы. Это предотвращает ошибки, которые могут возникнуть из-за взаимодействия с внешними зависимостями (например, с базой данных, сетью или другими компонентами).

Цель изоляции:

- **Минимизация побочных эффектов**: Изолированные тесты исключают влияние внешних факторов, таких как состояния других частей системы, на результаты теста.
    
- **Упрощение тестирования**: Изолированные модули проще тестировать, так как они не зависят от внешних компонентов.
    
- **Повторяемость тестов**: Изолированные тесты можно запускать в любом окружении и в любое время без зависимости от внешних ресурсов.
    

#### Виды тестовых заглушек:

1. **Мок-объекты (Mocks)**:
    
    - Моки используются для создания поддельных объектов, которые имитируют поведение реальных объектов. Моки позволяют проверять, как взаимодействуют другие объекты с тестируемым.
        
    - **Пример**:
        
        ```java
        List mockedList = mock(List.class);
        mockedList.add("one");
        mockedList.clear();
        verify(mockedList).add("one");
        verify(mockedList).clear();
        ```
        
2. **Шаблоны заглушек (Stubs)**:
    
    - Заглушки — это упрощенные версии реальных объектов, которые возвращают заранее определенные значения. Они используются, когда тестируемая функция зависит от другого компонента.
        
    - **Пример**:
        
        ```java
        class MyDatabaseStub extends Database {
            public String getData() {
                return "Stub Data";  // Заглушка для метода getData()
            }
        }
        ```
        
3. **Фейки (Fakes)**:
    
    - Фейки — это простые реализация, которые имитируют поведение настоящих объектов, но с упрощенной логикой. Например, это может быть "фейковая" база данных, которая хранит данные в памяти.
        
    - **Пример**:
        
        ```java
        class InMemoryDatabase extends Database {
            private Map<String, String> data = new HashMap<>();
        
            public void save(String key, String value) {
                data.put(key, value);
            }
        
            public String get(String key) {
                return data.get(key);
            }
        }
        ```
        
4. **Шпионские объекты (Spies)**:
    
    - Шпионы позволяют отслеживать взаимодействие с настоящими объектами, при этом все действия выполняются как обычно, но при этом можно проверять, какие методы были вызваны.
        
    - **Пример**:
        
        ```java
        List<String> spyList = spy(new ArrayList<>());
        spyList.add("one");
        spyList.add("two");
        
        verify(spyList).add("one");
        verify(spyList).add("two");
        ```
        

#### Пример использования тестовых заглушек:

Допустим, есть класс, который зависит от внешней службы (например, отправки сообщений). Мы можем использовать мок для имитации работы этой службы:

```java
class MessageService {
    public void sendMessage(String message) {
        // Реальная отправка сообщения
    }
}

class User {
    private MessageService messageService;

    public User(MessageService messageService) {
        this.messageService = messageService;
    }

    public void sendWelcomeMessage(String username) {
        messageService.sendMessage("Welcome, " + username);
    }
}

// В тесте:
@Test
public void testSendWelcomeMessage() {
    // Arrange
    MessageService mockMessageService = mock(MessageService.class);
    User user = new User(mockMessageService);

    // Act
    user.sendWelcomeMessage("John");

    // Assert
    verify(mockMessageService).sendMessage("Welcome, John");
}
```

Этот тест использует **мок-объект** для имитации поведения службы отправки сообщений и проверяет, что метод был вызван с правильным параметром.

### Заключение:

- **Изоляция** позволяет тестировать код в вакууме, без зависимости от внешних ресурсов.
    
- **Заглушки** помогают заменить реальные зависимости на их упрощенные версии, обеспечивая возможность контролировать поведение этих зависимостей в тестах.
    
- Различные виды заглушек (моки, фейки, шпионы и шаблоны) могут быть использованы в зависимости от нужд тестирования.

### 42. Опции драйвера. Работа с User-Agent

**Опции драйвера** в Selenium позволяют настраивать параметры поведения WebDriver, такие как запуск браузера в фоновом режиме, указание пути к драйверам и различные настройки конфигурации. Например, для настройки опций браузера, такие как использование прокси, включение или отключение расширений, использование конкретной версии браузера и т. д., можно использовать соответствующие классы, такие как `ChromeOptions`, `FirefoxOptions` и другие.

#### Пример использования **ChromeOptions**:

```java
ChromeOptions options = new ChromeOptions();
options.addArguments("--headless");  // Запуск браузера в фоновом режиме
options.addArguments("--start-maximized");  // Открытие браузера в максимизированном виде
WebDriver driver = new ChromeDriver(options);
```

#### Работа с **User-Agent**:

User-Agent — это строка, которая отправляется браузером на сервер при запросе, и она содержит информацию о браузере, операционной системе и других характеристиках устройства. В Selenium можно изменить User-Agent, чтобы сервер думал, что запрос пришел от другого браузера или устройства.

Чтобы изменить **User-Agent** с помощью **ChromeOptions**:

```java
ChromeOptions options = new ChromeOptions();
options.addArguments("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");
WebDriver driver = new ChromeDriver(options);
```

Этот код изменяет строку User-Agent для Chrome, чтобы при подключении сервер видел браузер с конкретной версией и настройками.

### 43. Что такое фикстуры? Назначение фикстур. Область видимости.

**Фикстуры** (fixtures) — это механизмы, которые позволяют настроить и очистить тестовую среду перед и после выполнения тестов. Они могут включать в себя создание объектов, настройку базы данных, подготовку тестовых данных и другие операции, которые должны выполняться до и после каждого теста или группы тестов.

#### Назначение фикстур:

- **Настройка окружения**: Фикстуры создают необходимое окружение для тестов, подготавливая все необходимые зависимости, такие как файлы, базы данных и другие ресурсы.
    
- **Очистка после теста**: Фикстуры могут использоваться для очистки данных или восстановления состояния системы после выполнения теста, чтобы другие тесты не повлияли на результаты.
    
- **Повторное использование**: Фикстуры позволяют избежать дублирования кода при настройке тестового окружения для нескольких тестов.
    

#### Область видимости фикстур:

- **Для каждого теста**: Фикстура создается и очищается для каждого теста отдельно. Это гарантирует, что тесты не влияют друг на друга.
    
- **Для каждого тестового класса**: Фикстура создается один раз для всего тестового класса и используется всеми тестами в этом классе.
    
- **Для всего теста**: Фикстура используется для всех тестов в проекте, обеспечивая единое состояние для всех тестов.
    

Пример фикстуры в **JUnit**:

```java
@Before
public void setUp() {
    // Подготовка окружения перед тестом
    driver = new ChromeDriver();
}

@After
public void tearDown() {
    // Очистка после теста
    driver.quit();
}
```

Здесь `setUp()` выполняется перед каждым тестом, а `tearDown()` — после каждого теста.

### 44. Категоризация тестов в Selenium. Управление тестами. Какая разница между статусом **skip** и **xfail**?

#### Категоризация тестов в Selenium:

В **Selenium** можно классифицировать тесты для удобства управления, особенно в большом проекте, где могут быть разные группы тестов:

- **Регрессионные тесты**: Тесты, которые проверяют, что изменения в коде не привели к нарушению ранее работавших функций.
    
- **Тесты функциональности**: Тесты, которые проверяют правильность реализации конкретных функций или требований.
    
- **Тесты производительности**: Тесты, которые измеряют производительность приложения, например, время отклика страницы.
    
- **Тесты безопасности**: Тесты, которые проверяют уязвимости и безопасность приложения.
    

#### Управление тестами:

Для управления тестами можно использовать фреймворки для тестирования, такие как **JUnit**, **TestNG**, или **PyTest**, которые позволяют организовывать тесты по группам, управлять их выполнением и отчетностью. Эти фреймворки поддерживают аннотации для упорядочивания тестов, фильтрации, и организации различных наборов тестов.

#### Разница между статусами **skip** и **xfail**:

- **skip** (Пропуск) — статус, который указывает, что тест не должен быть выполнен вообще, например, если тест временно не актуален или есть известные проблемы с окружением, которые мешают его выполнению. При пропуске теста результат не считается ошибкой, и тест просто не выполняется.
    
    Пример в **TestNG**:
    
    ```java
    @Test(enabled = false)
    public void testSkip() {
        // Этот тест не будет выполнен
    }
    ```
    
- **xfail** (Ожидаемая ошибка) — статус, который указывает, что тест **должен** провалиться, и это считается нормальным поведением. Это полезно, когда известно, что в текущей версии приложения есть ошибка, и тест должен подтверждать ее наличие. Если тест **не проваливается**, он считается неожиданным успехом (например, для обнаружения, что ошибка была исправлена).
    
    Пример в **pytest**:
    
    ```python
    import pytest
    
    @pytest.mark.xfail
    def test_failure():
        assert False  # Тест ожидаемо провалится
    ```
    

### Разница в результатах:

- **skip** — пропуск теста. Этот тест не выполняется, и его результат не считается ни успешным, ни неудачным.
    
- **xfail** — тест ожидаемо проваливается. Этот тест считается успешным, если он не проходит (так как это ожидаемое поведение).
    

### Заключение:

- **Фикстуры** помогают организовать подготовку и очистку окружения перед и после выполнения тестов.
    
- В **Selenium** можно управлять тестами, организуя их по категориям, и использовать такие статусы как **skip** и **xfail** для управления поведением тестов в специфических ситуациях.

### 45. Что такое POM (Page Object Model)? Основные принципы. Преимущества использования этой модели.

**Page Object Model (POM)** — это паттерн проектирования для автоматизации тестирования веб-приложений, который помогает разделить код тестов и код страницы. В этой модели каждая веб-страница представляется как объект, который инкапсулирует все элементы страницы и действия, которые можно с ними выполнить. Это позволяет легко поддерживать тесты и страницы в случае изменений в интерфейсе.

#### Основные принципы POM:

1. **Каждая страница как объект**: Каждая веб-страница (или компонент страницы) имеет свой класс, который представляет собой абстракцию этой страницы.
    
2. **Инкапсуляция элементов и действий**: Все элементы на странице инкапсулируются в виде полей класса, а действия (методы) над этими элементами описаны как методы в классе.
    
3. **Разделение логики тестов и логики страниц**: Логика взаимодействия с веб-страницей хранится в Page Object, а тесты — в отдельных классах, что делает тесты более читаемыми и поддерживаемыми.
    

#### Пример:

```java
// Page Object для страницы входа
public class LoginPage {
    private WebDriver driver;

    @FindBy(id = "username")
    private WebElement usernameField;

    @FindBy(id = "password")
    private WebElement passwordField;

    @FindBy(id = "loginButton")
    private WebElement loginButton;

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }

    public void login(String username, String password) {
        usernameField.sendKeys(username);
        passwordField.sendKeys(password);
        loginButton.click();
    }
}
```

#### Преимущества использования POM:

- **Поддерживаемость**: Легче поддерживать тесты, потому что изменения в интерфейсе или поведении страницы могут быть обновлены только в Page Object, а не во всех тестах.
    
- **Переиспользуемость**: Логика для работы с элементами страницы повторно используется в разных тестах.
    
- **Читаемость**: Тесты становятся более читаемыми, так как они фокусируются на высокоуровневой логике, а не на деталях реализации страниц.
    
- **Уменьшение дублирования**: Код для взаимодействия с элементами страницы пишется один раз и используется в разных тестах.
    

---

### 46. Тестирование API. Типы тестирования API.

**Тестирование API** — это процесс проверки функциональности, производительности, безопасности и надежности API (Application Programming Interface). API — это набор протоколов и инструментов, которые позволяют различным программам взаимодействовать друг с другом.

#### Типы тестирования API:

1. **Функциональное тестирование**: Проверка того, что API выполняет свои задачи согласно спецификации. Например, проверка корректности возвращаемых данных, обработки ошибок, правильности HTTP-методов (GET, POST, PUT, DELETE и т.д.).
    
2. **Тестирование производительности**: Оценка производительности API, включая тесты на нагрузку, стресс и масштабируемость. Проверка того, как API ведет себя при высокой нагрузке.
    
3. **Тестирование безопасности**: Оценка уязвимостей API. Проверка, насколько API защищено от атак, таких как SQL-инъекции, XSS, CSRF и другие угрозы безопасности.
    
4. **Тестирование совместимости**: Проверка, как API работает с различными версиями операционных систем, браузеров или других сторонних сервисов, с которыми оно должно взаимодействовать.
    
5. **Тестирование на доступность и отказоустойчивость**: Проверка, как API справляется с ситуациями отказа, например, если один из сервисов недоступен, и как API восстанавливается после сбоев.
    
6. **Тестирование с использованием данных**: Проверка правильности работы API с различными типами данных и их обработка. Это включает в себя проверку правильности сериализации и десериализации данных.
    

---

### 47. Проектирование тестирования API. Структура API теста. Инструменты для тестирования API.

#### Проектирование тестирования API:

1. **Определение цели тестирования**: Определите, какие аспекты API вы хотите протестировать: функциональность, производительность, безопасность и т.д.
    
2. **Определение входных данных**: Описание всех входных параметров, которые могут быть отправлены в API, включая обязательные и необязательные поля.
    
3. **Ожидаемые результаты**: Установите, что является правильным ответом API, включая статус-коды, тело ответа и заголовки.
    
4. **План тестирования**: Подготовьте сценарии тестов, которые включают в себя положительные и отрицательные тесты для различных случаев использования API.
    
5. **Автоматизация**: Используйте инструменты для автоматизации тестов, чтобы запускать их регулярно и интегрировать в процесс CI/CD.
    

#### Структура API теста:

1. **Настройка окружения**: Определение URL-адреса API, токенов аутентификации, заголовков запросов и других параметров.
    
2. **Отправка запроса**: Формирование запроса с нужными параметрами, например, с использованием метода `GET`, `POST`, `PUT`, `DELETE`.
    
3. **Проверка ответа**: Сравнение полученного ответа с ожидаемым результатом. Проверка статус-кода, тела ответа, заголовков.
    
4. **Очистка данных**: Если тест требует создания или модификации данных, возможно, потребуется очистить данные после выполнения теста.
    

#### Инструменты для тестирования API:

- **Postman**: Очень популярный инструмент для ручного тестирования RESTful API. Он позволяет легко отправлять запросы, просматривать ответы и автоматизировать тесты.
    
- **Swagger**: Используется для проектирования, тестирования и документации RESTful API.
    
- **RestAssured**: Библиотека для автоматизации тестирования REST API в Java.
    
- **JMeter**: Инструмент для нагрузочного тестирования API, поддерживающий различные типы запросов и сценариев.
    
- **SoapUI**: Инструмент для тестирования SOAP и REST API с возможностями нагрузочного тестирования.
    

---

### 48. Преимущества тестирования API. Основные проблемы при тестировании API.

#### Преимущества тестирования API:

1. **Раннее обнаружение ошибок**: API тесты позволяют обнаруживать ошибки на ранних стадиях, прежде чем они окажут влияние на более высокие уровни системы.
    
2. **Повторяемость тестов**: API тесты легко автоматизировать, и они могут быть использованы для регулярной проверки работоспособности API.
    
3. **Быстрота выполнения**: Тестирование API может быть быстрее, чем тестирование пользовательского интерфейса (UI), так как оно не требует загрузки браузера или взаимодействия с внешними интерфейсами.
    
4. **Проверка производительности**: API тесты позволяют измерять производительность и тестировать масштабируемость системы.
    
5. **Проверка интеграции**: API тесты позволяют проверять, как различные компоненты системы взаимодействуют друг с другом.
    

#### Основные проблемы при тестировании API:

1. **Неполные или неясные спецификации API**: Когда документация по API неполная или сложная для понимания, это затрудняет тестирование.
    
2. **Сложность в настройке окружения**: В некоторых случаях для тестирования API требуется сложная настройка тестовой среды, включая настройки баз данных или внешних сервисов.
    
3. **Тестирование производительности**: Проведение тестов производительности может быть сложным, особенно если нужно моделировать большие объемы данных или нагрузку.
    
4. **Изменения в API**: Когда API изменяется без должного обновления тестов, это может привести к сбоям и ложным результатам.
    
5. **Тестирование безопасности**: Определение уязвимостей API может быть сложным, особенно если тесты на безопасность не проводятся систематически.
    

---

### Заключение:

Тестирование API является важной частью процесса разработки программного обеспечения, позволяя убедиться, что система работает корректно и надежно. Разработка тестов для API требует тщательной настройки окружения и планирования, а также использования инструментов для автоматизации тестирования и обеспечения качества API.

### 49. Что такое нестабильные тесты? Причины их появления.

**Нестабильные тесты** — это тесты, которые не всегда дают одинаковый результат при повторном запуске, даже если код, который тестируется, не изменился. Эти тесты могут быть как ложными срабатываниями (false positives), так и пропусками ошибок (false negatives).

#### Причины появления нестабильных тестов:

1. **Зависимость от внешних сервисов**: Тесты, которые зависят от внешних сервисов или API, могут давать нестабильные результаты из-за нестабильности этих сервисов.
    
2. **Проблемы с синхронизацией**: Веб-приложения могут быть асинхронными, и тесты, которые не учитывают правильное время ожидания (например, на загрузку данных), могут не получить правильный результат.
    
3. **Неопределенные данные**: Тесты, работающие с переменными данными (например, данные из базы данных, которые могут изменяться), могут быть нестабильными.
    
4. **Проблемы с конфигурацией окружения**: Различия в конфигурации тестового окружения (например, версия браузера, версия операционной системы) могут вызвать нестабильность тестов.
    
5. **Невозможность изолировать тесты**: Если тесты не изолированы друг от друга, предыдущие тесты могут повлиять на результаты следующих, что делает тесты нестабильными.
    

#### Как бороться с нестабильными тестами:

- Использование **моков** или **заглушек** для замены внешних зависимостей.
    
- Внедрение **явных ожиданий** (например, `WebDriverWait` для Selenium).
    
- Убедитесь, что тесты **изолированы** и не зависят от состояния других тестов.
    
- Повторный запуск тестов на разных конфигурациях и устройствах для выявления нестабильности.
    

---

### 50. Метрики в тестировании. Какие бывают. Зачем их собирать.

**Метрики в тестировании** — это числовые показатели, которые помогают анализировать эффективность процесса тестирования, качество программного обеспечения и процесс разработки. Они позволяют отслеживать прогресс, выявлять проблемы и принимать обоснованные решения.

#### Основные метрики тестирования:

1. **Количество тестов**: Число выполненных тестов, как положительных, так и отрицательных.
    
2. **Процент прохождения тестов**: Это процент тестов, которые прошли успешно, от общего числа.
    
    - Формула: `(Количество успешных тестов / Общее количество тестов) * 100`
        
3. **Процент неудачных тестов**: Число тестов, которые завершились с ошибками.
    
    - Формула: `(Количество неудачных тестов / Общее количество тестов) * 100`
        
4. **Покрытие кода**: Процент кода, который был протестирован. Включает покрытие по строкам, ветвям и путям.
    
5. **Скорость выполнения тестов**: Время, которое требуется для выполнения всех тестов или группы тестов.
    
6. **Дефекты**:
    
    - **Количество дефектов, обнаруженных на разных стадиях** тестирования.
        
    - **Частота повторных дефектов**.
        
7. **Время до исправления**: Среднее время, которое требуется на исправление ошибок после их обнаружения.
    
8. **Процент тестов, автоматизированных**: Это соотношение автоматизированных тестов к общему числу тестов.
    

#### Зачем собирать метрики:

- **Отслеживание качества**: Метрики помогают понять, на каком уровне находится качество программного продукта.
    
- **Управление рисками**: Помогает выявить проблемные области в приложении.
    
- **Оптимизация процесса тестирования**: Данные о времени выполнения тестов могут помочь оптимизировать процесс тестирования.
    
- **Планирование**: Метрики помогают оценить трудозатраты и время, необходимое для выполнения всех тестов.
    

---

### 51. Виды тестового покрытия. Как рассчитать?

**Тестовое покрытие** — это метрика, которая измеряет, сколько частей программного обеспечения было протестировано с помощью автоматизированных или ручных тестов. Оно показывает, насколько полно тестируется приложение.

#### Виды тестового покрытия:

1. **Покрытие по строкам**:
    
    - Оценивает процент строк кода, которые были выполнены в процессе тестирования.
        
    - Формула: `(Количество выполненных строк / Общее количество строк) * 100`
        
2. **Покрытие по ветвям**:
    
    - Измеряет процент всех возможных путей выполнения программы, которые были протестированы.
        
    - Формула: `(Количество протестированных ветвей / Общее количество ветвей) * 100`
        
3. **Покрытие по функциям**:
    
    - Показывает, сколько процентов функций или методов было вызвано в ходе тестирования.
        
    - Формула: `(Количество протестированных функций / Общее количество функций) * 100`
        
4. **Покрытие по условиям**:
    
    - Оценка того, сколько условий в программе было протестировано, включая if-else блоки.
        
5. **Покрытие по путям**:
    
    - Измеряет тестирование различных путей, которые могут быть выполнены в программе, включая все комбинации условий.
        

#### Как рассчитать:

Для каждого типа покрытия можно использовать инструменты для анализа покрытия, такие как **JaCoCo** для Java, **Clover**, или **Cobertura**. Эти инструменты автоматически собирают данные о том, какие участки кода были выполнены.

---

### 52. Цели и задачи тестирования безопасности веб-приложений.

**Тестирование безопасности веб-приложений** направлено на выявление уязвимостей и угроз безопасности в веб-приложениях с целью защиты данных и обеспечения безопасной работы приложения в различных условиях.

#### Цели тестирования безопасности:

- **Обнаружение уязвимостей**: Тестирование направлено на поиск и устранение уязвимостей, которые могут быть использованы злоумышленниками.
    
- **Защита данных**: Проверка, насколько эффективно приложение защищает конфиденциальные данные пользователей (например, пароли, личные данные).
    
- **Предотвращение атак**: Проверка защиты от распространенных атак, таких как SQL-инъекции, XSS (межсайтовое выполнение сценариев), CSRF (межсайтовая подделка запроса) и другие.
    
- **Соблюдение стандартов безопасности**: Обеспечение соответствия приложения стандартам безопасности (например, PCI DSS для обработки платежных данных).
    

#### Задачи тестирования безопасности:

- **Аудит кода**: Проверка исходного кода на наличие уязвимостей.
    
- **Тестирование на проникновение**: Проверка системы на устойчивость к различным типам атак.
    
- **Анализ аутентификации и авторизации**: Проверка надежности механизма аутентификации и управления доступом.
    
- **Тестирование на утечку данных**: Проверка защиты данных от утечек и несанкционированного доступа.
    

---

### 53. Основные угрозы безопасности веб-сайтов. Методы защиты от угроз на этапе кодирования.

#### Основные угрозы:

1. **SQL-инъекции**: Атаки, при которых злоумышленник вставляет SQL-запросы в форму ввода данных.
    
    - **Защита**: Использование параметризированных запросов и ORM (Object-Relational Mapping).
        
2. **XSS (межсайтовые скриптовые атаки)**: Вставка вредоносного JavaScript-кода на веб-страницу, который выполняется на стороне пользователя.
    
    - **Защита**: Экранирование пользовательского ввода, использование CSP (Content Security Policy).
        
3. **CSRF (межсайтовая подделка запроса)**: Атаки, при которых злоумышленник заставляет пользователя выполнить непреднамеренные действия на сайте.
    
    - **Защита**: Использование токенов безопасности в формах и запросах (например, CSRF токены).
        
4. **Cross-Site WebSocket Hijacking**: Перехват WebSocket-соединений для доступа к данным.
    
    - **Защита**: Использование HTTPS и проверка происхождения запросов.
        
5. **Инсайдерские угрозы**: Угрозы от сотрудников, которые имеют доступ к внутренним данным.
    
    - **Защита**: Минимизация прав доступа и использование логирования и аудита.
        

---

### 54. Методы тестирования безопасности веб-приложений. Инструменты.

#### Методы тестирования безопасности:

1. **Тестирование на проникновение (Penetration Testing)**: Имитирует атаки, чтобы найти уязвимости в приложении.
    
2. **Динамическое тестирование безопасности (DAST)**: Тестирование безопасности в процессе работы приложения, проверка его реакции на попытки атак.
    
3. **Статическое тестирование безопасности (SAST)**: Проверка исходного кода на наличие уязвимостей.
    
4. **Анализ зависимости (Dependency Scanning)**: Проверка сторонних библиотек и зависимостей на наличие уязвимостей.
    

#### Инструменты для тестирования безопасности:

- **OWASP ZAP (Zed Attack Proxy)**: Открытый инструмент для динамического тестирования безопасности.
    
- **Burp Suite**: Мощный набор инструментов для тестирования безопасности веб-приложений.
    
- **Nikto**: Сканер для тестирования уязвимостей веб-серверов.
    
- **SonarQube**: Инструмент для статического анализа безопасности кода.
    
- **Nessus**: Инструмент для обнаружения уязвимостей на различных уровнях инфраструктуры.
    

---

Тестирование безопасности веб-приложений критически важно для защиты данных пользователей и предотвращения атак, поэтому важно регулярно выполнять его на различных этапах разработки и эксплуатации приложения.